'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://github.com/Dogfalo/materialize/blob/master/js/tooltip.js
var Tooltip = function (_PureComponent) {
	(0, _inherits3.default)(Tooltip, _PureComponent);

	function Tooltip() {
		var _ref;

		var _temp, _this, _ret;

		(0, _classCallCheck3.default)(this, Tooltip);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = Tooltip.__proto__ || (0, _getPrototypeOf2.default)(Tooltip)).call.apply(_ref, [this].concat(args))), _this), _this.show = function () {
			// Play tooltip showing animation
			var animate = false;

			// If hiding animation is being played,
			// then cancel it, and cancel setting
			// `display` to `none` after it finishes playing.
			if (_this.hide_timeout) {
				clearTimeout(_this.hide_timeout);
				_this.hide_timeout = undefined;

				// Abort tooltip hiding animation.
				// It will automatically return to the "showing" state.
				_this.tooltip.classList.remove('rrui__tooltip--before-hide');
			}
			// Otherwise, the tooltip is hidden (or never been shown)
			else {
					if (!_this.tooltip) {
						_this.create_tooltip();
					}

					// this.tooltip.style.display = 'block'

					// Play tooltip showing animation
					animate = true;
				}

			var _this$calculate_coord = _this.calculate_coordinates(),
			    x = _this$calculate_coord.x,
			    y = _this$calculate_coord.y;

			_this.tooltip.style.left = x + 'px';
			_this.tooltip.style.top = y + 'px';

			// Play tooltip showing animation
			// (doing it after setting position because
			//  setting position applies `display: block`)
			if (animate) {
				_this.tooltip.classList.add('rrui__tooltip--after-show');
			}
		}, _this.hide = function () {
			var hidingAnimationDuration = _this.props.hidingAnimationDuration;

			// If already hiding, or if already hidden, then do nothing.
			// if (this.hide_timeout || this.tooltip.style.display === 'none')

			if (_this.hide_timeout || !_this.tooltip) {
				return;
			}

			// Play tooltip hiding animation
			_this.tooltip.classList.add('rrui__tooltip--before-hide');

			// Set the tooltip to `display: none`
			// after its hiding animation finishes.
			_this.hide_timeout = setTimeout(function () {
				_this.hide_timeout = undefined;
				_this.destroy_tooltip();
				// this.tooltip.style.display = 'none'
				// this.tooltip.classList.remove('rrui__tooltip--before-hide')
				// this.tooltip.classList.remove('rrui__tooltip--after-show')
			}, hidingAnimationDuration);
		}, _this.on_mouse_enter = function () {
			var text = _this.props.text;

			// mouse enter and mouse leave events
			// are triggered on mobile devices too

			if (_this.mobile) {
				return;
			}

			// If the tooltip has no text then don't show it.
			if (!text) {
				return;
			}

			// Shouldn't happen, because
			// `mouse leave` event clears this timeout.
			if (_this.show_timeout) {
				return;
			}

			var delay = _this.props.delay;

			// Don't show the tooltip immediately
			// but rather wait for the user to
			// "mouse over" it for a short time interval.
			// (prevents false positives)

			_this.show_timeout = setTimeout(function () {
				_this.show_timeout = undefined;
				_this.show();
			}, delay);
		}, _this.on_mouse_leave = function () {
			// mouse enter and mouse leave events
			// are triggered on mobile devices too
			if (_this.mobile) {
				return;
			}

			// If tooltip hasn't been shown yet,
			// then cancel showing it.
			if (_this.show_timeout) {
				clearTimeout(_this.show_timeout);
				_this.show_timeout = undefined;
				return;
			}

			// Otherwise, the tooltip is shown, so hide it.
			_this.hide();
		}, _this.on_touch_start = function () {
			var text = _this.props.text;

			// mouse enter events won't be processed from now on

			_this.mobile = true;

			// If the tooltip has no text then don't show it.
			if (!text) {
				return;
			}

			_this.show();
		}, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
	}

	(0, _createClass3.default)(Tooltip, [{
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps(_ref2) {
			var text = _ref2.text;

			// Update tooltip text
			if (this.tooltip && text !== this.props.text) {
				this.tooltip.textContent = text;
			}
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			clearTimeout(this.show_timeout);
			this.show_timeout = undefined;

			clearTimeout(this.hide_timeout);
			this.hide_timeout = undefined;

			this.destroy_tooltip();
		}
	}, {
		key: 'create_tooltip',
		value: function create_tooltip() {
			var _props = this.props,
			    text = _props.text,
			    tooltipClassName = _props.tooltipClassName;


			this.tooltip = document.createElement('div');

			// this.tooltip.style.display  = 'none'
			this.tooltip.style.position = 'absolute';
			this.tooltip.style.left = 0;
			this.tooltip.style.top = 0;

			this.tooltip.classList.add('rrui__tooltip');

			if (tooltipClassName) {
				this.tooltip.classList.add(tooltipClassName);
			}

			this.tooltip.textContent = text;

			this.container().appendChild(this.tooltip);
		}
	}, {
		key: 'destroy_tooltip',
		value: function destroy_tooltip() {
			if (this.tooltip) {
				// Won't throw an exception
				this.tooltip.parentNode.removeChild(this.tooltip);
				this.tooltip = undefined;
			}
		}
	}, {
		key: 'container',
		value: function container() {
			var container = this.props.container;

			return container();
		}
	}, {
		key: 'calculate_coordinates',
		value: function calculate_coordinates() {
			var width = this.tooltip.offsetWidth;
			var height = this.tooltip.offsetHeight;

			var origin = _reactDom2.default.findDOMNode(this.origin);

			var origin_width = origin.offsetWidth;
			// const origin_height = origin.offsetHeight

			var _offset = offset(origin);

			var top = _offset.top - height - offset(this.container()).top;
			var left = _offset.left + origin_width / 2 - width / 2;

			return reposition_within_screen(left, top, width, height);
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			// Shows tooltip on mouse over when on desktop.
			// Shows tooltip on touch when on mobile.

			var _props2 = this.props,
			    inline = _props2.inline,
			    style = _props2.style,
			    className = _props2.className,
			    children = _props2.children,
			    text = _props2.text,
			    delay = _props2.delay,
			    hidingAnimationDuration = _props2.hidingAnimationDuration,
			    container = _props2.container,
			    tooltipClassName = _props2.tooltipClassName,
			    rest = (0, _objectWithoutProperties3.default)(_props2, ['inline', 'style', 'className', 'children', 'text', 'delay', 'hidingAnimationDuration', 'container', 'tooltipClassName']);


			return _react2.default.createElement(
				'div',
				(0, _extends3.default)({}, rest, {
					ref: function ref(_ref3) {
						return _this2.origin = _ref3;
					},
					onMouseEnter: this.on_mouse_enter,
					onMouseLeave: this.on_mouse_leave,
					onTouchStart: this.on_touch_start,
					onTouchMove: this.hide,
					onTouchEnd: this.hide,
					onTouchCancel: this.hide,
					style: inline ? style ? (0, _extends3.default)({}, inline_style, style) : inline_style : style,
					className: (0, _classnames2.default)('rrui__tooltip__target', className) }),
				children
			);
		}
	}]);
	return Tooltip;
}(_react.PureComponent);

Tooltip.propTypes = {
	// Tooltip text
	text: _propTypes2.default.string,

	// Whether this element should be displayed as `inline-block`.
	// (is `true` by default)
	inline: _propTypes2.default.bool.isRequired,

	// The delay before the tooltip is shown (in milliseconds)
	delay: _propTypes2.default.number.isRequired,

	// The duration of the tooltip hiding animation.
	// The DOM element will retain `display: block` for this time period.
	// When changing this timeout also change `transition` time for
	// `.tooltip--after-show` and `.tooltip--before-hide` CSS classes.
	// Is `120` by default.
	hidingAnimationDuration: _propTypes2.default.number.isRequired,

	// `container: () => DOMElement` property is optional
	// and is gonna be the parent DOM Element for the tooltip itself
	// (`document.body` by default).
	// (in which case make sure that `document.body` has no `margin`
	//  otherwise tooltip `left` and `top` positions will be slightly off).
	container: _propTypes2.default.func,

	// CSS style object
	style: _propTypes2.default.object,

	// CSS class name
	className: _propTypes2.default.string,

	// Tooltip CSS class name
	tooltipClassName: _propTypes2.default.string
};
Tooltip.defaultProps = {
	inline: true,
	delay: 200, // in milliseconds
	hidingAnimationDuration: 120, // in milliseconds
	container: function container() {
		return document.body;
	}
};
exports.default = Tooltip;


function reposition_within_screen(x, y, width, height) {
	var minimal_margin = 4; // in pixels

	if (x < minimal_margin) {
		x = minimal_margin;
	} else if (x + width + minimal_margin > window.innerWidth) {
		x -= x + width + minimal_margin - window.innerWidth;
	}

	if (y < window.pageYOffset + minimal_margin) {
		y = window.pageYOffset + minimal_margin;
	} else if (y + height + minimal_margin > window.pageYOffset + window.innerHeight) {
		y -= y + height + minimal_margin - (window.pageYOffset + window.innerHeight);
	}

	return { x: x, y: y };
}

// http://stackoverflow.com/questions/5598743/finding-elements-position-relative-to-the-document
function offset(element) {
	var rect = element.getBoundingClientRect();

	var client_left = document.clientLeft || document.body.clientLeft || 0;
	var client_top = document.clientTop || document.body.clientTop || 0;

	var top = rect.top + window.pageYOffset - client_top;
	var left = rect.left + window.pageXOffset - client_left;

	return { top: top, left: left };
}

var inline_style = {
	display: 'inline-block'
};
//# sourceMappingURL=Tooltip.js.map